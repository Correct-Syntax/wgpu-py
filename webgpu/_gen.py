"""
Script to parse wgpu.h and generate wgpu.py
"""

import os


class TextOb:
    """ An object that can be used to read from a str in a nice way.
    """

    def __init__(self, text):
        self._text = text
        self._length = len(text)
        self._pos = 0

    def end_reached(self):
        return self._pos >= self._length

    def read_until(self, char):
        start = self._pos
        while self._pos < self._length:
            c = self._text[self._pos]
            self._pos += 1
            if c == char:
                return self._text[start:self._pos]
        return ""

    def readline(self):
        return self.read_until("\n")


# %% Parse

hfile = TextOb(open("wgpu.h", "rb").read().decode())

constants = {}
enums = {}
structs = {}
functions = {}
types = {}

unknown_lines = []


while not hfile.end_reached():

    line = hfile.readline()

    if not line.strip():
        pass
    elif line.startswith("/*"):
        if "*/" in line:
            pass
        else:
            raise RuntimeError("Cannot handle multiline comments yet.")
    elif line.startswith("#include "):
        pass
    elif line.startswith("#if !defined(WGPU_REMOTE)"):
        pass
    elif line.startswith("#endif"):
        pass
    elif line.startswith("#define "):
        parts = line.split()
        if len(parts) == 3:
            constants[parts[1].strip()] = int(parts[2].strip())
        elif "WGPU_LOCAL" in line:
            pass
        else:
            unknown_lines.append(line)
    elif line.startswith("typedef enum {"):
        line += hfile.read_until("}") + hfile.readline()
        lines = line.strip().split("\n")
        name = lines[-1].split("}", 1)[1].strip("; ")
        d = {}
        for i, line in enumerate(lines[1:-1]):
            key, _, val = line.strip().strip(",;").partition("=")
            val = val.strip()
            if not val:
                val = i
            d[key.strip()] = int(val)
        enums[name] = d
    elif line.startswith("typedef struct"):
        line += hfile.read_until("}") + hfile.readline()
        lines = line.strip().split("\n")
        name = lines[-1].split("}", 1)[1].strip("; ")
        if not name:
            line += hfile.read_until("}") + hfile.readline()
            unknown_lines.append(line)
            continue
        d = {}
        for line in lines[1:-1]:
            arg = line.strip().strip(",;")
            if arg.startswith("const "):
                arg = arg[6:]
            arg_type, arg_name = arg.strip().split()
            d[arg_name.strip(' *')] = arg_type
        structs[name] = d
    elif line.startswith("typedef "):
        parts = line.strip().strip(";").split()
        if len(parts) == 3:
            types[parts[2]] = parts[1]
        else:
            unknown_lines.append(line)
    elif (line.startswith("void ") or line.startswith("WGPU")) and "wgpu_" in line:
        if ")" not in line:
            line += hfile.read_until(")") + hfile.readline()
        # Get name
        name = line.split("(")[0].strip().split()[-1].strip()
        # Parse args
        assert line.count("(") == 1
        raw_args = line.split("(")[1].split(")")[0].split(",")
        args = []
        for arg in raw_args:
            arg = arg.strip()
            if arg.startswith("const "):
                arg = arg[6:]
            arg_type, arg_name = arg.strip().split()
            args.append((arg_name.strip(' *'), arg_type))
        # Collect
        functions[name] = dict(line=line, args=args)
    else:
        unknown_lines.append(line)


def pythonise_type(t):
    t = types.get(t, t)
    t = types.get(t, t)  # because can be XX -> XXDummy -> uint32_t
    if t in ("float", "double"):
        return "float"
    elif t in ("int32_t", "int64_t", "uint32_t", "uint64_t"):
        return "int"
    elif t.endswith("_t"):
        return t[:-2]
    elif t.startswith("WGPU"):
        return t[4:]
    else:
        return t

def type_annotation(t):
    t = pythonise_type(t)
    if t in ("int", "float"):
        return f": {t}"
    elif t == "void":
        return ""
    else:
        return f": {t!r}"


# Summarize
if unknown_lines:
    print(f"===== Could not parse {len(unknown_lines)} lines:")
    for line in unknown_lines:
        print(line.rstrip())
    print("=====")
else:
    print(f"All lines where parsed")
print(f"Found {len(constants)} constants")
print(f"Found {len(enums)} enums")
print(f"Found {len(structs)} structs")
print(f"Found {len(functions)} functions")


# %% Generate

module_doc = """
THIS CODE IS AUTOGENERATED - DO NOT EDIT
"""

class_doc = """
Abstract base class for the WebGPU API.
"""


pylines = []

pylines.append(f'"""\n{module_doc.strip()}\n"""\n')
pylines.append("\nclass BaseWGPU:")
pylines.append(f'    """ {class_doc.strip()}\n    """')

pylines.append("\n    # %% Functions")
for name, d in functions.items():
    assert name.startswith("wgpu_")
    name = name[5:]
    args = [arg[0] + type_annotation(arg[1]) for arg in d['args']]
    pylines.append(f"\n    def {name}(self, {', '.join(args)}):")
    pylines.append(f'        """')
    for line in d['line'].strip().splitlines():
        pylines.append("        " + line)
    pylines.append(f'        """')
    pylines.append("        raise NotImplementedError()")

pylines.append("\n    # %% Structs\n")
for name, vals in structs.items():
    assert name.startswith("WGPU")
    name = name[4:]
    c_args = [t + " " + key for key, t in vals.items()]
    py_args = [key + type_annotation(t) for key, t in vals.items()]
    dict_args = [f'"{key}": {key}' for key in vals.keys()]
    pylines.append(f"\n    def create_{name}({', '.join(py_args)}):")
    pylines.append(f'        """ ' + ", ".join(c_args) + ' """')
    pylines.append("        return {"+ ", ".join(dict_args) + "}")

pylines.append("\n    # %% Constants\n")
for name, val in constants.items():
    assert name.startswith("WGPU")
    name = name[4:]
    pylines.append(f"    {name} = {val!r}")

pylines.append("\n    # %% Enums\n")
for name, subs in enums.items():
    assert name.startswith("WGPU")
    name = name[4:]
    pylines.append(f"    # {name}")
    for sub_name, sub_val in subs.items():
        assert sub_name.startswith("WGPU")
        sub_name = sub_name[4:]
        # assert sub_name.startswith(name)
        pylines.append(f"    {sub_name} = {sub_val!r}")

pylines.append("")

# Write

with open("wgpu.py", "wb") as f:
    f.write("\n".join(pylines).encode())
print("Written to wgpu.py")
